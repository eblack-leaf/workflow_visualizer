<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Workflow_Visualizer</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="pages/workflow.html"><strong aria-hidden="true">2.</strong> Workflow Impl</a></li><li class="chapter-item expanded "><a href="pages/sender.html"><strong aria-hidden="true">3.</strong> Sender</a></li><li class="chapter-item expanded "><a href="pages/visualizer.html"><strong aria-hidden="true">4.</strong> Visualizer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pages/job.html"><strong aria-hidden="true">4.1.</strong> Job</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pages/attach.html"><strong aria-hidden="true">4.1.1.</strong> Attach</a></li><li class="chapter-item expanded "><a href="pages/sync.html"><strong aria-hidden="true">4.1.2.</strong> Sync</a></li></ol></li><li class="chapter-item expanded "><a href="pages/coord.html"><strong aria-hidden="true">4.2.</strong> Coord</a></li><li class="chapter-item expanded "><a href="pages/grid.html"><strong aria-hidden="true">4.3.</strong> Grid</a></li><li class="chapter-item expanded "><a href="pages/path.html"><strong aria-hidden="true">4.4.</strong> Path</a></li><li class="chapter-item expanded "><a href="pages/gfx.html"><strong aria-hidden="true">4.5.</strong> Gfx</a></li><li class="chapter-item expanded "><a href="pages/viewport.html"><strong aria-hidden="true">4.6.</strong> Viewport</a></li><li class="chapter-item expanded "><a href="pages/render.html"><strong aria-hidden="true">4.7.</strong> Render</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pages/text_renderer.html"><strong aria-hidden="true">4.7.1.</strong> TextRenderer</a></li><li class="chapter-item expanded "><a href="pages/line_renderer.html"><strong aria-hidden="true">4.7.2.</strong> LineRenderer</a></li><li class="chapter-item expanded "><a href="pages/panel_renderer.html"><strong aria-hidden="true">4.7.3.</strong> PanelRenderer</a></li></ol></li><li class="chapter-item expanded "><a href="pages/visibility.html"><strong aria-hidden="true">4.8.</strong> Visibility</a></li><li class="chapter-item expanded "><a href="pages/focus.html"><strong aria-hidden="true">4.9.</strong> Focus</a></li><li class="chapter-item expanded "><a href="pages/touch.html"><strong aria-hidden="true">4.10.</strong> Touch</a></li><li class="chapter-item expanded "><a href="pages/orientation.html"><strong aria-hidden="true">4.11.</strong> Orientation</a></li><li class="chapter-item expanded "><a href="pages/instance_tools.html"><strong aria-hidden="true">4.12.</strong> InstanceTools</a></li><li class="chapter-item expanded "><a href="pages/time.html"><strong aria-hidden="true">4.13.</strong> Time</a></li></ol></li><li class="chapter-item expanded "><a href="pages/runner.html"><strong aria-hidden="true">5.</strong> Runner</a></li><li class="chapter-item expanded "><a href="pages/platform_specifics.html"><strong aria-hidden="true">6.</strong> Platform Specifics</a></li><li class="chapter-item expanded "><a href="tutorial/begin.html"><strong aria-hidden="true">7.</strong> Tutorial</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Workflow_Visualizer</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="workflow-visualizer"><a class="header" href="#workflow-visualizer">Workflow Visualizer</a></h1>
<p>The crate workflow_visualizer is a rust lib for cross-platform UI applications.
The structure of this lib works by creating a headless app with actions and responses
that trigger reactions in the UI layer. </p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<h3 id="workflow"><a class="header" href="#workflow">Workflow</a></h3>
<p>The process starts with defining your workflow. This is done by implementing <a href="pages/workflow.html"><code>Workflow</code></a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Engen {
    // your data here to run app
}
impl Workflow for Engen {
    type Action = ();
    type Response = ();
    fn handle_response(visualizer: &amp;mut Visualizer, response: Self::Response) {
        // trigger actions in the visualizer to show the effects of responses
    }
    fn handle_action&lt;'async_trait&gt;(
        engen: Arc&lt;Mutex&lt;Self&gt;&gt;,
        action: Self::Action
    ) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Self::Response&gt; + Send + 'async_trait&gt;&gt;
        where
            Self: 'async_trait {
        // handle any engen tasks related to an action
        // ...async connect to a database for user data
        // ...fetch content from network request
        // return a Response to signal to the Visualizer
    }
    fn exit_action() -&gt; Self::Action{
        // tell visualizer what action is the exit action 
    }
    fn exit_response() -&gt; Self::Response{
        // tell visualizer what response is the exit response
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This establishes a communication protocol between a UI thread and a thread run in background for
your application actions. This is the structure of how an app runs using workflow_visualizer. 
This is a headless app as it only concerns itself with actions in to your app and the
responses that it generates. For this app to do anything visually we need another part.</p>
<h3 id="visualizer"><a class="header" href="#visualizer">Visualizer</a></h3>
<p>Next we have to instantiate a <a href="pages/visualizer.html"><code>Visualizer</code></a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let theme = Theme::default();
let gfx_options = GfxOptions::native_defaults();
let mut visualizer = Visualizer::new(theme, gfx_options);
// config visualizer ...
<span class="boring">}</span></code></pre></pre>
<p>This is a suite of rendering tools that are attached to a <a href="pages/job.html"><code>Job</code></a>. A <code>Job</code> is a <code>Container</code> for data
and a set of <code>Task</code>s to run functions on the container. One important purpose for a job is to collect various render pipelines
and provide a structure to create a render pass, and call any render functions that are attached to the job; 
see <a href="pages/render.html"><code>Render</code></a>. The visualizer also interprets input actions
such as providing listeners for touches/mouse input; see <a href="pages/touch.html"><code>Touch</code></a>. The visualizer has
a <a href="pages/viewport.html"><code>Viewport</code></a> to convert screen coordinates to NDC coordinates used by Vulkan | DirectX12 | Metal.
This is used by renderers to correctly position elements using <a href="pages/coord.html"><code>Coord</code></a> system which accounts for
scale factor of the device by using different <code>CoordContext</code>s. <a href="pages/visibility.html"><code>Visibility</code></a> can be determined by 
reading from an elements associated component. Visible elements can receive <a href="pages/focus.html"><code>Focus</code></a> to show
on-screen keyboard using <code>VirtualKeyboard</code> and receive input. Prebuilt core render pipelines are included
by default such as <a href="pages/text_renderer.html"><code>TextRenderer</code></a>, which is a memory-efficient glyph-caching text renderer which can be 
utilized by spawning a <code>Text</code> element. Other pipelines are available that are common to UI applications. 
If nothing quite solves your desired effect you can easily integrate your own renderer by implementing 
<a href="pages/render.html"><code>Render</code></a> to setup the render function and <a href="pages/attach.html"><code>Attach</code></a> to configure how the renderer attaches to the 
visualizer's <a href="pages/job.html"><code>Job</code></a>.</p>
<h3 id="runner"><a class="header" href="#runner">Runner</a></h3>
<p>All of this structure needs an entry point. The <a href="pages/runner.html"><code>Runner</code></a> is responsible for establishing
a connection to the compositor on the platform and obtaining a window to draw within. The runner forwards events from 
the connection and links it to the appropriate calls into the visualizer. This event loop never returns control due to platform 
implementation details. A background thread is spawned before entering this loop and a bridge created using the definitions 
in <a href="pages/workflow.html"><code>Workflow</code></a> trait. To communicate to the application thread, a <a href="pages/sender.html"><code>Sender</code></a> can be used to 
send actions. This process should return a response and the UI thread will receive this response and react 
accordingly.</p>
<h4 id="native-run"><a class="header" href="#native-run">Native Run</a></h4>
<h6 id="desktop"><a class="header" href="#desktop">Desktop</a></h6>
<p>When running natively on desktop, dimensions can be specified to get a fixed size to develop with.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Runner::new()
    .with_desktop_dimensions((400, 600))
    .native_run::&lt;Engen&gt;(visualizer);
<span class="boring">}</span></code></pre></pre>
<p>This is all that is needed to run on desktop.</p>
<h6 id="android"><a class="header" href="#android">Android</a></h6>
<p>The runner also supports Android applications. To achieve this a few steps are needed.
To link with the android lifecycle the implementation refers to an Android
compatibility struct called AndroidApp. This serves as a pointer to android-activity that powers the event loop on Android and allows
accessing system functionality.
This must be given to a separate main function and then passed to the visualizer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_os = &quot;android&quot;)]
#[no_mangle]
fn android_main(android_app: AndroidApp) {
    tracing_subscriber::fmt().init();
    let mut visualizer = visualizer::visualizer();
    visualizer.set_gfx_options(GfxOptions::limited_environment());
    Runner::new()
        .with_android_app(android_app)
        .native_run::&lt;Engen&gt;(visualizer);
}
<span class="boring">}</span></code></pre></pre>
<p>The android entry point must be defined in Cargo.toml as a dynamic lib.</p>
<pre><code class="language-toml">[lib]
name = &quot;application&quot;
crate-type = [&quot;cdylib&quot;]
path = &quot;src/main.rs&quot;
</code></pre>
<p>The application must extend GameActivity in Java and compile using cargo-ndk. See <a href="pages/platform_specifics.html">Platform Specifics</a> for more information.</p>
<h4 id="web-run"><a class="header" href="#web-run">Web Run</a></h4>
<p>To run on the web, extra setup is needed. Web workers allow separate processes in the browser and are taken advantage of 
in this lib. </p>
<p>A main function to start a web worker must be defined.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    start_web_worker::&lt;Engen&gt;();
}</code></pre></pre>
<p>A common build program for wasm is Trunk. Trunk supports web workers and can be configured by putting</p>
<pre><code class="language-toml">[[bin]]
name = &quot;worker&quot;
path = &quot;src/worker_main.rs&quot;
</code></pre>
<p>in your Cargo.toml and</p>
<pre><code class="language-html">&lt;link data-trunk rel=&quot;rust&quot; href=&quot;Cargo.toml&quot; data-wasm-opt=&quot;z&quot; data-bin=&quot;worker&quot; data-type=&quot;worker&quot; /&gt;
</code></pre>
<p>in the index.html that serves as entry point for your Trunk build. Due to how web worker api is formed you need to
tell the visualizer the path of the web worker as so</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Runner::new().web_run::&lt;Engen&gt;(visualizer, &quot;./worker.js&quot;.to_string());
<span class="boring">}</span></code></pre></pre>
<p>The path in Trunk builds is the name of the binary defined in the index.html. See <a href="pages/platform_specifics.html">Platform Specifics</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workflow-1"><a class="header" href="#workflow-1">Workflow</a></h1>
<p>The first part to set up is the trait <code>Workflow</code>. This is defined as</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait Workflow
where
    Self: Default,
{
    type Action: Debug
        + Clone
        + PartialEq
        + Send
        + Sync
        + Sized
        + 'static
        + Serialize
        + for&lt;'a&gt; Deserialize&lt;'a&gt;;
    type Response: Debug
        + Clone
        + PartialEq
        + Send
        + Sync
        + Sized
        + 'static
        + Serialize
        + for&lt;'a&gt; Deserialize&lt;'a&gt;;
    fn handle_response(visualizer: &amp;mut Visualizer, response: Self::Response);
    fn exit_action() -&gt; Self::Action;
    fn exit_response() -&gt; Self::Response;
    async fn handle_action(engen: Arc&lt;Mutex&lt;Self&gt;&gt;, action: Self::Action) -&gt; Self::Response;
}
<span class="boring">}</span></code></pre></pre>
<p>Lets break this down.</p>
<h4 id="action--response"><a class="header" href="#action--response">Action | Response</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Action;
type Response;
<span class="boring">}</span></code></pre></pre>
<p>These associated types define what is considered input to your app (<code>Action</code>) and the
<code>Response</code>s they generate. Responses are the signals for triggering reactions in the UI. 
Having these types allows structured input to the app that clarify what can be sent.</p>
<h4 id="handlers"><a class="header" href="#handlers">Handlers</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn handle_action(engen: Arc&lt;Mutex&lt;Self&gt;&gt;, action: Self::Action) -&gt; Self::Response;
fn handle_response(visualizer: &amp;mut Visualizer, response: Self::Response);
<span class="boring">}</span></code></pre></pre>
<p>These define how to handle actions and responses defined above. When the <a href="pages/runner.html"><code>Runner</code></a> starts
your app, it starts two processes. One for the UI to react to input, and one to run async tasks that
would otherwise block the UI thread until completed. To handle an action the trait needs to define an async fn.
This is possible due to a crate <code>async_trait</code> which wraps the async fn in a <code>Pin&lt;Box&lt;Future&lt;...&gt;&gt;</code> to make it
compatible with the current way traits are defined. Recently a MVP for integrating async fn in traits was announced
so this will be moot in the coming months. The <code>handle_response</code> is sync because it runs inside the UI thread which is 
single threaded due to the nature of how receiving events from the system is implemented.</p>
<h4 id="exit-logic"><a class="header" href="#exit-logic">Exit Logic</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn exit_action() -&gt; Self::Action;
fn exit_response() -&gt; Self::Response;
<span class="boring">}</span></code></pre></pre>
<p>These point the visualizer to the actions/responses that signify exiting. This allows the visualizer to 
stop the UI thread and send a similar response to the application thread to save state and confirm the exit.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>Natively this lib uses <a href="https://tokio.rs/"><code>tokio.rs</code></a> to spawn a sophisticated async runtime which efficiently 
runs asynchronous tasks with performant scheduling. The threads more resemble multi-plexing within a core rather than 
sending it off to a different core.</p>
<p>In the browser, native threads cannot be used for security reasons. Web workers are sandboxed processes that can be 
spawned using javascript to accomplish this need. This has a different trait from the useful crate <code>gloo_worker</code> that needs
to be implemented. The <code>Workflow</code> mod blanket implements this for any struct that impls <code>Workflow</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sender"><a class="header" href="#sender">Sender</a></h1>
<h3 id="definition"><a class="header" href="#definition">Definition</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Sender&lt;T: Workflow + Default + 'static&gt; { /* private fields */ }
<span class="boring">}</span></code></pre></pre>
<p>The sender is used by the application to send actions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn send(&amp;self, action: &lt;T as Workflow&gt;::Action) {}
<span class="boring">}</span></code></pre></pre>
<p>is its only method and can be accessed from a <code>NonSend</code> resource in the visualizer's <a href="pages/job.html"><code>Job</code></a>.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Engen {
    // your app data
}
enum Action {
    Notify(String),
}
impl Workflow for Engen {
    // ...
    type Action = Action;
    // ...
}
fn system(sender: NonSend&lt;Sender&lt;App&gt;&gt;, /* other params */) {
    // do stuff that needs to send action ...
    sender.send(Action::Notify(...));
}
<span class="boring">}</span></code></pre></pre>
<p>This action will be sent to the application thread and <code>Workflow::handle_action</code> will be run to give you 
space to respond with what is needed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visualizer-1"><a class="header" href="#visualizer-1">Visualizer</a></h1>
<p>The <code>Visualizer</code> handles displaying visual elements needed by the application. This uses a <a href="pages/job.html"><code>Job</code></a> to create
an extensible container that holds tasks for running fns on the data. This is used to run a render pass that invokes
any render fns attached to the visualizer and presents to the surface of window initialized by the <a href="pages/runner.html"><code>Runner</code></a>.
The visualizer is composed of many parts which build on each other to provide a specific solution of a responsive UI
and is best explained by delving into each section specifically. The next section is <a href="pages/job.html"><code>Job</code></a> to start us off.
This is the central glue for all the various parts. Each module attached to the <code>Visualizer</code> has been
vetted to elide repetitive systems from running when no updating has been done that could
change each aspect thanks to the <code>Filter</code> system paired with <code>ChangeDetection</code> that tracks 
mutable access to components. </p>
<h3 id="interface-overview"><a class="header" href="#interface-overview">Interface Overview</a></h3>
<h5 id="init"><a class="header" href="#init">Init</a></h5>
<p>First is the <code>Visualizer::new(...)</code>.
This creates 5 main <code>Task</code>s that help the visualizer handle interactions, and respond accordingly.
Next is the option to <code>Visualizer::set_gfx_options(...)</code> which can be used to reset the <code>GfxOptions</code>
after instantiation. There is an <code>async Visualizer::init_gfx(...)</code> which is used to create the <code>Gfx</code> module and <code>Viewport</code>.
This is the core initialization fn.
Attachments need to be invoked to insert into the <code>Job</code>. This can be accomplished with
<code>Visualizer::initialize(...)</code>.</p>
<h5 id="attachments"><a class="header" href="#attachments">Attachments</a></h5>
<p>With <code>Visualizer::add_attachment::&lt;impl Attach&gt;()</code> the system can be extended with logic handlers.
Using <code>Visualizer::register_renderer::&lt;impl Render&gt;()</code> the system can add render fns to the render pass.</p>
<h5 id="helpers"><a class="header" href="#helpers">Helpers</a></h5>
<p>You can <code>Visualizer::trigger_resize(...)</code> to resize the viewport and surface configuration.
The <code>Theme</code> can be changed via <code>Visualizer::set_theme(...)</code>.
Entities can be added by invoking <code>Visualizer::add_entities(...)</code> or <code>Visualizer::add_named_entities(...)</code>.
Scale factor can be set via <code>Visualizer::set_scale_factor(...)</code>.</p>
<h5 id="input"><a class="header" href="#input">Input</a></h5>
<p>Touch events can be registered with <code>Visualizer::register_touch(...)</code>.
Mouse clicks can be registered with <code>Visualizer::register_mouse_click(...)</code>.
Mouse location can be set with <code>Visualizer::set_mouse_location(...)</code>.
Touches/Clicks can be cancelled with <code>Visualizer::cancel_touches()</code>.</p>
<h5 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h5>
<p>A <code>Visualizer</code> can be controlled with <code>::suspend()</code> | <code>::resume()</code> | <code>::setup()</code> 
| <code>::exec()</code> | <code>::render()</code> | <code>::teardown()</code></p>
<p>See <a href="pages/../../doc/workflow_visualizer/index.html">API</a> doc for full reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="job"><a class="header" href="#job">Job</a></h1>
<p>A <code>Job</code> is a struct for executing <code>Task</code>s which run functions on data in a <code>Container</code>. </p>
<h3 id="container"><a class="header" href="#container">Container</a></h3>
<p>A <code>Container</code> can hold <code>Res</code> or resources which have one slot per type, or it can hold
<code>Entity</code>s composed of many types associating them with a unique id to reference the parts.
See <a href="https://docs.rs/bevy/latest/bevy/ecs/prelude/struct.World.html"><code>bevy_ecs::World</code></a> for more information.</p>
<h3 id="task"><a class="header" href="#task">Task</a></h3>
<p>A <code>Task</code> is a scheduled set of fns to run on the <code>Container</code>. These fns can be grouped into <code>SystemSet</code>s to
synchronize when parts of the schedule should be done before/after other sets.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(SystemSet)]
enum Sets {
    First,
}
let task = Task::new();
task.add_systems((some_fn.in_set(Sets::First)));
<span class="boring">}</span></code></pre></pre>
<p>Which would add <code>some_fn</code> to the set <code>First</code>. 
This is a thin wrapper around <a href="https://docs.rs/bevy/latest/bevy/ecs/prelude/struct.Schedule.html"><code>bevy_ecs::Schedule</code></a>.</p>
<h5 id="execution-state"><a class="header" href="#execution-state">Execution State</a></h5>
<p>A <code>Job</code> includes an <code>ExecutionState</code> to allow for <code>Visualizer::suspend()</code> and <code>Visualizer::resume()</code> to be pause execution on
mobile platforms when minimizing the app. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>job.suspend();// sets ExecutionState to Suspended
job.resume();// sets ExecutionState to Resumed
<span class="boring">}</span></code></pre></pre>
<h4 id="storing-entities"><a class="header" href="#storing-entities">Storing Entities</a></h4>
<p>A <code>Job</code> can store entities associated with an id to reference specific entities in systems.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = job.container.spawn(/* bundle */).id();
job.store_entity(&quot;special&quot;, entity); 
// ...
let data = job.get_entity::&lt;Components&gt;(&quot;special&quot;).unwrap();
<span class="boring">}</span></code></pre></pre>
<h5 id="exit--idle"><a class="header" href="#exit--idle">Exit | Idle</a></h5>
<p>On creation a <code>Job</code> inserts <code>Exit</code> and <code>Idle</code> resources to aid in control flow.</p>
<h5 id="idle"><a class="header" href="#idle">Idle</a></h5>
<p><code>Idle</code> can be set in systems by bringing in the resource</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn system(idle: ResMut&lt;Idle&gt;) {
    idle.can_idle = false;
}
<span class="boring">}</span></code></pre></pre>
<p>When set to <code>false</code> the <code>Runner</code> sets the control flow to poll again.
When set to <code>true</code> the <code>Runner</code> sets the control flow to wait for user input 
or hardware events. A system is inserted to attempt to set <code>Idle.can_idle</code> to <code>true</code>
at the beginning of every frame. You can set this to <code>false</code> any time in your loop to 
signal that execution should keep running even without input, such as in animations.</p>
<h5 id="exit"><a class="header" href="#exit">Exit</a></h5>
<p><code>Exit</code> can be set in a similar way.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn system(exit: ResMut&lt;Exit&gt;) {
    exit.request_exit();
}
<span class="boring">}</span></code></pre></pre>
<p>This will signal the event loop that it should exit and send <code>Workflow::exit_action()</code> to 
your application to gracefully handle shutdown.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attach"><a class="header" href="#attach">Attach</a></h1>
<p>The <code>Attach</code> trait helps integrate the various parts needed to make 
a <code>Visualizer</code> work. Simply put it gives you a ref to the <code>Visualizer</code> and 
you can do whatever you want with it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Attach {
    fn attach(visualizer: &amp;mut Visualizer);
}
<span class="boring">}</span></code></pre></pre>
<p>It formalizes adding things to the extensible <code>Container</code>, and it adds
an indirection between adding things directly to the <code>Container</code>. There are
core resources not attached until the <code>Window</code> can be obtained, yet renderers 
want to use these structs to make textures and bind groups. The <code>Visualizer</code> defers
these calls by wrapping the needed <code>Attach::attach(...)</code> in an <code>Attachment</code> to 
be invoked when needed.</p>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Attachee {}
impl Attach for Attachee {
    fn attach(visualizer: &amp;mut Visualizer) {
        // ...
    }
}
visualizer.add_attachment::&lt;Attachee&gt;();
<span class="boring">}</span></code></pre></pre>
<p>Which queues an</p>
<h4 id="attachment"><a class="header" href="#attachment">Attachment</a></h4>
<p>You wont use this type directly but here it is for reference.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Attachment(pub Box&lt;fn(&amp;mut Visualizer)&gt;);

impl Attachment {
    pub fn using&lt;T: Attach&gt;() -&gt; Self {
        Self(Box::new(T::attach))
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syncpoints"><a class="header" href="#syncpoints">SyncPoints</a></h1>
<p>To parallelize as much as possible a <code>Task</code> will run its systems 
alongside other systems that can be run while preserving order of
mutable access to components and resources. This can be configured using
<code>SyncPoint</code>s. </p>
<h3 id="core-syncpoints"><a class="header" href="#core-syncpoints">Core SyncPoints</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SyncPoint {
    Event,
    Initialization,
    Config,
    PreProcessVisibility,
    Preparation,
    Spawn,
    Reconfigure,
    PostProcessVisibility,
    Resolve,
    PushDiff,
    Finish,
}
<span class="boring">}</span></code></pre></pre>
<p>There are many stages to the <code>Task</code>s that are run on the visualizer's <code>Job</code>.
Here is the overview of sync points. </p>
<ul>
<li><code>JobSyncPoint::Idle</code> set holds <code>attempt_to_idle</code> to set idling behavior.</li>
<li><code>SyncPoint::Event</code> set holds all the event updaters to process new events.</li>
<li><code>SyncPoint::Initialization</code> set is for preparation of resources and entities.</li>
<li><code>UserSpaceSyncPoint::Initialization</code> set in for user initialization.</li>
<li><code>SyncPoint::Config</code> set is for configuring the initialized parts.</li>
<li><code>SyncPoint::PreProcessVisibility</code> set is for setting visibility before processing begins.</li>
<li><code>SyncPoint::Preparation</code> set is for preparing parts according to the config.</li>
<li><code>UserSpaceSyncPoint::Process</code> set is for user fns.</li>
<li><code>SyncPoint::Spawn</code> set is for spawning new bundles via <code>Request</code>s.</li>
<li><code>SyncPoint::Reconfigure</code> set is for config new parts spawned</li>
<li><code>SyncPoint::PostProcessVisibility</code> set is for determining visibility after processing.</li>
<li><code>SyncPoint::Resolve</code> set is for resolving diffs in parts after changes.</li>
<li><code>UserSpaceSyncPoint::Resolve</code> set is for resolving user fns.</li>
<li><code>SyncPoint::PushDiff</code> set is for extracting the differences in element state.</li>
<li><code>SyncPoint::Finish</code> set is for cleanup after extraction.</li>
</ul>
<h3 id="userspace-syncpoints"><a class="header" href="#userspace-syncpoints">UserSpace SyncPoints</a></h3>
<p>These sync points are put in place to be correct within the context of the 
core sync points and provide clean sets where the user can add systems. When implementing
<code>Attach::attach</code> these are the main sets to be concerned with for correct execution.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum UserSpaceSyncPoint {
    Initialization,
    Process,
    Resolve,
}
<span class="boring">}</span></code></pre></pre>
<h6 id="userspacesyncpointinitialization"><a class="header" href="#userspacesyncpointinitialization">UserSpaceSyncPoint::Initialization</a></h6>
<p>This gives a spot for the user to attach systems that initialize data and is ensured to run
after core visualizer elements have been initialized.</p>
<h6 id="userspacesyncpointprocess"><a class="header" href="#userspacesyncpointprocess">UserSpaceSyncPoint::Process</a></h6>
<p>This should be used to compute and update any values that need doing once per frame.
This runs after input/events have been processed and focus/visibility set. This is 
the only spot to request new entities from and have them spawn immediately. This lib
uses a <a href="pages/request.html"><code>Request</code></a> to wrap any new bundles and when paired with a 
<code>request::spawn::&lt;Bundle&gt;(...)</code> system inserted in the <code>SyncPoint::Spawn</code> set, it will
correctly spawn to have all pipelines process appropriately. Due to the nature of 
ECS pattern it can be hard to recognize when a component will run in a system unintentionally
before it has all its parts which would opt the entity out of the unintentional system.
It is clearer to define a boundary when all need to be ready and use <code>Request</code> to wrap 
your bundles.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bundle = ...;
let req = Request::new(bundle);
visualizer.add_entities(vec![req]);
visualizer.job.task(/* TaskLabel */)
    .add_systems((request::spawn::&lt;Bundle&gt;.in_set(SyncPoint::Spawn),));
<span class="boring">}</span></code></pre></pre>
<h6 id="userspacesyncpointresolve"><a class="header" href="#userspacesyncpointresolve">UserSpaceSyncPoint::Resolve</a></h6>
<p>This should be used to read the state after all elements have been spawned and
processed, but before sending data to the render <code>Extraction</code>s which check a
<code>Cache</code> and decide what to give to the render task. This is useful for reacting to changes
made by the system started in <code>UserSpaceSyncPoint::Process</code>.</p>
<h3 id="labeled-tasks"><a class="header" href="#labeled-tasks">Labeled Tasks</a></h3>
<p>The <code>Visualizer</code> labels <code>Task</code>s that handle preparation for the system to run. Some of these tasks have
a limited set of these <code>SyncPoint</code>s as they need to handle less ambiguity of logic. You can
refer to these by using the associated constants on the <code>Visualizer</code> impl.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>visualizer.job.task(Visualizer::TASK_MAIN).add_systems((...));
<span class="boring">}</span></code></pre></pre>
<h5 id="visualizertask_startup"><a class="header" href="#visualizertask_startup">Visualizer::TASK_STARTUP</a></h5>
<p>This task is run once after initialization of the <code>Attachment</code>s queued in the visualizer.</p>
<ul>
<li><code>SyncPoint::Initialization</code></li>
<li><code>UserSpaceSyncPoint::Initialization</code></li>
<li><code>SyncPoint::Preparation</code></li>
<li><code>SyncPoint::Resolve</code></li>
<li><code>UserSpaceSyncPoint::Resolve</code></li>
<li><code>SyncPoint::Finish</code></li>
</ul>
<h5 id="visualizertask_main"><a class="header" href="#visualizertask_main">Visualizer::TASK_MAIN</a></h5>
<p>This task is run every iteration of the event loop, while <code>!job.suspended()</code>.</p>
<ul>
<li><code>JobSyncPoint::Idle</code></li>
<li><code>SyncPoint::Event</code></li>
<li><code>SyncPoint::Initialization</code></li>
<li><code>UserSpaceSyncPoint::Initialization</code></li>
<li><code>SyncPoint::Config</code></li>
<li><code>SyncPoint::PreProcessVisibility</code></li>
<li><code>SyncPoint::Preparation</code></li>
<li><code>UserSpaceSyncPoint::Process</code></li>
<li><code>SyncPoint::Spawn</code></li>
<li><code>SyncPoint::Reconfigure</code></li>
<li><code>SyncPoint::PostProcessVisibility</code></li>
<li><code>SyncPoint::Resolve</code></li>
<li><code>UserSpaceSyncPoint::Resolve</code></li>
<li><code>SyncPoint::PushDiff</code></li>
<li><code>SyncPoint::Finish</code></li>
</ul>
<h5 id="visualizertask_render_startup"><a class="header" href="#visualizertask_render_startup">Visualizer::TASK_RENDER_STARTUP</a></h5>
<p>This task is run once after the initialization of the <code>Attachment</code>s queued in the visualizer.</p>
<ul>
<li><code>SyncPoint::Initialization,</code></li>
<li><code>UserSpaceSyncPoint::Initialization,</code></li>
<li><code>SyncPoint::Preparation,</code></li>
<li><code>SyncPoint::Resolve,</code></li>
<li><code>UserSpaceSyncPoint::Resolve,</code></li>
<li><code>SyncPoint::Finish,</code></li>
</ul>
<h5 id="visualizertask_render_main"><a class="header" href="#visualizertask_render_main">Visualizer::TASK_RENDER_MAIN</a></h5>
<p>This task is run every time a redraw is requested.</p>
<ul>
<li><code>JobSyncPoint::Idle,</code></li>
<li><code>SyncPoint::Initialization,</code></li>
<li><code>UserSpaceSyncPoint::Initialization,</code></li>
<li><code>SyncPoint::Preparation,</code></li>
<li><code>SyncPoint::Resolve,</code></li>
<li><code>UserSpaceSyncPoint::Resolve,</code></li>
<li><code>SyncPoint::Finish,</code></li>
</ul>
<p>The <code>Task</code>s labeled &quot;*_MAIN&quot; have an extra set <code>JobSyncPoint::Idle</code> to communicate with 
the control_flow of the event loop.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coordinates"><a class="header" href="#coordinates">Coordinates</a></h1>
<p>To position things, the struct <code>Coordinates</code> helps by providing</p>
<ul>
<li><code>Position</code> the x/y of the entity</li>
<li><code>Area</code> the width/height of the entity</li>
<li><code>Layer</code> the z-value of the entity for ordering depth
This is all wrapped in a </li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Coordinate&lt;Context: CoordContext&gt; {
    #[bundle]
    pub section: Section&lt;Context&gt;,
    pub layer: Layer,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="parts"><a class="header" href="#parts">Parts</a></h3>
<p>The <code>Coordinate</code> struct is a composition of another bundle <code>Section</code> and a <code>Layer</code>. A <code>Section</code> is
a bundle of <code>Position</code> and <code>Area</code>. This spawns all the components separately for orthogonality in 
designing systems to utilize these parts.</p>
<p>A <code>Coordinate</code> uses a <code>CoordinateContext</code> to differentiate different
types of coordinate values. There are 3 contexts provided by the visualizer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl CoordinateContext for DeviceContext {}
impl CoordinateContext for InterfaceContext {}
impl CoordinateContext for NumericalContext {}
<span class="boring">}</span></code></pre></pre>
<h3 id="scale--dpi"><a class="header" href="#scale--dpi">Scale | Dpi</a></h3>
<p>All UI elements should be assigned coordinates within the <a href="pages/grid.html"><code>Grid</code></a>, but for 
understanding how coordinates work, UI coordinates use <code>InterfaceContext</code> to display correctly on devices
that require scaling to present correctly. Mobile devices have high resolution screens yet are
a fraction of the size of desktop monitors. Drawing a shape at 50x50 on desktop would be very small
on a device with higher dots per inch (dpi). <code>ScaleFactor</code> holds a f64 to be used to multiply to get the
needed size of an element in <code>DeviceContext</code>. It is used to divide <code>DeviceContext</code> coordinates to get to
<code>InterfaceContext</code>. Developers should design for the middle ground of 1920x1080 which is considered a
scale factor of <code>1</code>. The same <code>InterfaceContext</code> coordinates will be correctly scaled to fit on different
sized devices. The <code>Viewport</code>'s interface section will be smaller on higher dpi devices however, so using raw 
coordinates might be off-screen when running the same layout on desktop/mobile. To account for this
a <a href="pages/grid.html"><code>Grid</code></a> is established and should be the primary way to instruct UI elements where to be.</p>
<h4 id="devicecontext"><a class="header" href="#devicecontext">DeviceContext</a></h4>
<p>This context is for coordinates in physical space such as hardware dimensions for the window.
The <code>desktop_dimensions</code> that are passed to <code>Runner::new().with_desktop_dimensions(...)</code> is an 
example of <code>DeviceContext</code>.</p>
<h4 id="interfacecontext"><a class="header" href="#interfacecontext">InterfaceContext</a></h4>
<p>This context is for coordinates in logical space such as UI positioning. This is needed to 
account for scale factor of the device being run on. <code>ScaleFactor</code> holds a reference to 
the platforms info to be used in conversion between contexts.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn system(scale_factor: Res&lt;ScaleFactor&gt;) {
    // ...
    let interface_context_pos = device_context_pos.to_interface(scale_factor.factor);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="numericalcontext"><a class="header" href="#numericalcontext">NumericalContext</a></h4>
<p>This context is agnostic to device/logical and is used for representing 
numbers without associating screen positioning semantics. Useful for inheriting the
methods of <code>Coordinate</code> without it mixing with your interface positioning.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let non_ui_coord = Coordinate::&lt;NumericalContext&gt;::new(...);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grid"><a class="header" href="#grid">Grid</a></h1>
<p>The <code>Grid</code> is responsible for placing elements consistently across different screen
sizes and scales. Elements that employ the use of <code>ResponsiveGridView</code> will have the
views defined there configured to an adaptive grid of 8px <code>Marker</code>s that mark points
for assigning <code>Position</code>s. The <code>Viewport</code> area is divided by these <code>Marker</code>s and grouped
to become columns/rows. The <code>ColumnConfig</code> stores a <code>base</code> <code>MarkerGrouping</code> which denotes
how many <code>Marker</code>s are in a column. The <code>RowConfig</code> takes after the size of the column
<code>base</code> for consistent alignment. The <code>ColumnConfig</code> also uses another <code>MarkerGrouping</code>
for an <code>extension</code> which adds space evenly to all columns if the <code>Viewport</code> width is not
covered by the <code>base</code> column size. Between exist <code>Gutter</code>s that help space content consistently.
The <code>GutterConfig</code> starts small and then extends the gutter size when more screen space is
available.</p>
<h3 id="span"><a class="header" href="#span">Span</a></h3>
<p>There are 3 <code>Span</code>s to the grid, each of which contains different <code>Grid</code> configuration.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum HorizontalSpan {
    Four,
    Eight,
    Twelve,
}
<span class="boring">}</span></code></pre></pre>
<p>The name denotes the number of logical columns available at that size.
The <code>Viewport</code> size determines the <code>Span</code>.</p>
<ul>
<li>From ~ - 720px the <code>Grid</code> uses <code>HorizontalSpan::Four</code> (Mobile)</li>
<li>From 721px - 1168px the <code>Grid</code> uses <code>HorizontalSpan::Eight</code> (Tablet)</li>
<li>From 1169px - ~ the <code>Grid</code> uses <code>HorizontalSpan::Twelve</code> (Desktop)</li>
</ul>
<p>This allows predetermined logical spacers to guide placement across a
valid range of device sizes that need adaptive positioning. Knowing the exact
column count instead of growing with variable columns as needed keeps the placement consistent.
This does require that a view be specified for each <code>HorizontalSpan</code> however.</p>
<h3 id="usage-2"><a class="header" href="#usage-2">Usage</a></h3>
<p>To use the grid, add 'ResponsiveGridView' as a component to an entity.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>visualizer.add_entities(vec![Request::new((
    ResponsiveGridView::all_same(((1.near(), 4.far()), (1.near(), 1.far().offset(-4)))),
    // ... more components
))]);
<span class="boring">}</span></code></pre></pre>
<p>This example sets the same view for each <code>HorizontalSpan</code> with <code>::all_same(view)</code>.
The notation is {<code>GridMarker</code>}.{<code>GridMarkerBias</code>}(){.offset(<code>RawMarker</code>)}.
This signifies that the <code>1</code> should be the <code>GridMarker</code> or the index of the logical grouping
of <code>RawMarker</code>s is the first column. The <code>Column</code> has a <code>.near()</code> and a <code>.far()</code> bias.
This can be used to latch to either side of the <code>Column</code>. An <code>.offset(...)</code> is used
for more fine-grained positioning where just a <code>Column</code> and a <code>Bias</code> does not suffice.
The <code>.offset(...)</code> adds a relative offset of <code>RawMarker</code> using the 8px grid points directly
instead of a logical column/row grouping index to add to the initial marker placing.
The points are grouped in two pairs. Horizontal begin/end and Vertical begin/end.
This constitutes a <code>GridRange</code> when specified for <code>horizontal</code> and <code>vertical</code> it makes
a <code>GridView</code> that can be calculated to obtain a <code>Position</code> | <code>Area</code>.</p>
<p>This would be all that is needed except that the <code>Grid</code> has different
column numbers at different <code>Span</code>s. Setting mobile first guidelines using the
<code>HorizontalSpan::Four</code> and <code>::all_same(...)</code> is a good starting place and will work
on larger <code>Span</code>s as four columns exist within 8/12. To maximize benefits of the <code>Grid</code>
an <code>ResponsiveGridView::explicit(four, eight, twelve)</code> which defines elements using
the entire available space should be used. If three layouts are not needed, a
<code>ResponsiveGridView</code> can be used with <code>.with_span_eight(...)</code> to only specify an
extra layout for the <code>HorizontalSpan::Eight</code>.</p>
<h3 id="helpers-1"><a class="header" href="#helpers-1">Helpers</a></h3>
<p><code>Grid.calc_section(view)</code> can be used to get the <code>Section&lt;InterfaceContext&gt;</code> for the
current <code>Span</code>. Similarly, <code>Grid.calc_horizontal_location(location)</code> and
<code>Grid.calc_vertical_location(location)</code> can obtain the <code>RawMarker</code> that corresponds
to the given location.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="gfx"><a class="header" href="#gfx">Gfx</a></h1>
<p>This holds the wgpu <code>Surface</code> | <code>Device</code> | <code>Queue</code> | <code>Config</code>. These parts obtain a drawable
surface, a gpu device to use for acceleration, a queue to submit commands to this gpu, and the
configuration of the surface (formats / size). This is needed to power all the render pipelines
and present to the window created during run. </p>
<h3 id="gfxoptions"><a class="header" href="#gfxoptions">GfxOptions</a></h3>
<p>When creating a <code>Visualizer</code>, you will need to pass it <code>GfxOptions</code>. This can be used to configure how
your application uses the <code>Gfx</code> stack and what environment is needed. Desktop platforms generally can run
<code>GfxOptions::native_defaults()</code> without concern. Mobile/Web platforms might want to downgrade the limits using
<code>GfxOptions::limited_environment()</code> which will lower certain aspects commonly not implemented on these platforms.</p>
<p>Your main interaction with this struct will be extending the visualizer with custom pipelines. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn system(gfx: Res&lt;GfxSurface&gt;, config: Res&lt;GfxSurfaceConfiguration&gt;, msaa: Res&lt;MsaaRenderAdapter&gt;) {
    // ... use parts
    // gfx.device/surface/queue
    // config.config.width/height
    // msaa.requested(); // the requested level of sampling/anti-aliasing from
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>MsaaRenderAdapter</code> can be used to request multi-sampling and anti-aliasing for your renderers e.g.
<code>GfxOptions::native_defaults().with_msaa(4)</code>.</p>
<h3 id="learn-more"><a class="header" href="#learn-more">Learn More</a></h3>
<p>For more information check out the amazing work being done at <a href="https://wgpu.rs/"><code>wgpu.rs</code></a>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="viewport"><a class="header" href="#viewport">Viewport</a></h1>
<p>The <code>Viewport</code> is central to all rendering as it integral to correctly positioning
elements. Here is the definition.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Viewport {
    pub(crate) cpu: CpuViewport,
    pub(crate) gpu: GpuViewport,
    pub bind_group: wgpu::BindGroup,
    pub bind_group_layout: wgpu::BindGroupLayout,
    pub(crate) uniform: Uniform&lt;GpuViewport&gt;,
    pub(crate) depth_texture: wgpu::Texture,
    pub(crate) depth_format: wgpu::TextureFormat,
    pub(crate) offset: ViewportOffset,
    pub(crate) offset_uniform: Uniform&lt;ViewportOffset&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This holds the data for an 
<a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/orthographic-projection-matrix.html"><code>orthographic</code></a>
matrix that converts coordinates to NDC coordinates which are limited to -1/1, from screen coordinates such
as the elements <code>Coordinate</code>. It takes the current window size and creates a logical version (Cpu) and a 
uniform buffer on the <code>Gpu</code>. This needs to be used via the <code>pub</code> fields <code>bind_group</code> and <code>bind_group_layout</code> 
in shaders to multiply against to get the correct normalized position.</p>
<pre><code class="language-wgsl">struct Viewport {
    view_matrix: mat4x4&lt;f32&gt;,
};
@group(0)
@binding(0)
var&lt;uniform&gt; viewport: Viewport;
@group(0)
@binding(1)
var&lt;uniform&gt; viewport_offset: vec4&lt;f32&gt;;
// ... {
    var offset_coordinates = vec4&lt;f32&gt;(coordinates.rg - viewport_offset.rg, coordinates.ba);
    let ndc = vec4&lt;f32&gt;(viewport.view_matrix * offset_coordinates);
// ... }
</code></pre>
<p>The <code>viewport</code> is the matrix which needs to be multiplied by your coordinates to return NDC coordinates.
This is what is expected by the shader vertex output.</p>
<p>The <code>viewport_offset</code> is the current position of the viewport used to scroll where the UI is looking 
at. This is set using <code>ViewportHandle</code>. You must first offset your elements x/y before multiplying.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn system(handle: ResMut&lt;ViewportHandle&gt;) {
    handle.position_adjust(...);// to change offset
    let section: Section&lt;InterfaceContext&gt; = handle.section();// for using bounds of Viewport 
}
<span class="boring">}</span></code></pre></pre>
<p>This is in two parts to allow systems running things with the rendering tool <code>Viewport</code> do not
interfere with the logical handle <code>ViewportHandle</code> and thus have two different uniforms. This is also
performant for updating position repeatedly as the UI scrolls because the matrix data does not need to be 
changed as the <code>Viewport</code> is not changing size and thus less sent over to gpu. </p>
<h3 id="depth"><a class="header" href="#depth">Depth</a></h3>
<p>The <code>Viewport</code> also holds the depth buffer as it is correlated in size to the <code>Viewport</code> dimensions
and must be recreated when resized. The near layer is <code>Layer::new(0)</code> and the far is <code>Layer::new(100)</code>.
All layers should be within this bound to not be clipped by the <code>Viewport</code> during culling by the gpu.</p>
<h4 id="usage-in-renderers"><a class="header" href="#usage-in-renderers">Usage in Renderers</a></h4>
<p>Include the bind_group_layout</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let layout_descriptor = wgpu::PipelineLayoutDescriptor {
        label: Some(&quot;pipeline layout descriptor&quot;),
        bind_group_layouts: &amp;[
            &amp;viewport.bind_group_layout,
            // ...
        ],
        push_constant_ranges: &amp;[],
    };
<span class="boring">}</span></code></pre></pre>
<p>Specify the depth format</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let depth_stencil_state = Some(wgpu::DepthStencilState {
        format: viewport.depth_format(),
        // ...
    });
<span class="boring">}</span></code></pre></pre>
<p>Set the <code>bind_group</code> in your <code>Render::render</code> fn</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>render_pass_handle
            .0
            .set_bind_group(0, &amp;viewport.bind_group, &amp;[]);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="render"><a class="header" href="#render">Render</a></h1>
<p>Rendering is the main purpose of the <code>Visualizer</code>. <a href="pages/gfx.html"><code>Gfx</code></a> module points to information
on how this lib uses <a href="https://wgpu.rs">wgpu.rs</a> to achieve this goal. The core part of rendering is
the <code>wgpu::RenderPass</code> which allows recording of commands to the gpu available. This loads the memory
for the surface and rasterizes the draw calls. Presentation of this surface works in FIFO mode (swapping
surface textures is a chain to not interrupt device rendering) and constrains itself to a single <code>RenderPass</code>
as loading memory to do a second render pass is very costly on (especially on mobile devices). This centralizes
where rendering happens and creates an efficient solution for presenting to the device.</p>
<h3 id="render-trait"><a class="header" href="#render-trait">Render Trait</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Render {
    fn phase() -&gt; RenderPhase;
    fn render&lt;'a&gt;(&amp;'a self, render_pass_handle: &amp;mut RenderPassHandle&lt;'a&gt;, viewport: &amp;'a Viewport);
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>render</code> fn allows access to the <code>RenderPass</code> via a handle and the <a href="pages/viewport.html"><code>Viewport</code></a> to
integrate the <code>bind_group</code>/<code>layout</code> into shaders. Access to <code>&amp;self</code> is available to hold any
data needed to render such as <code>wgpu::Buffer</code>s or <code>wgpu::Texture</code>s.</p>
<p><code>fn phase() -&gt; RenderPhase</code> is for signaling what phase this <code>render</code> should take place in.
<code>RenderPhase::Opaque</code> fns are run first as no blending is present.
<code>RenderPhase::Alpha(priority)</code> is used for renderers that wish to use alpha-blending and 
happens after opaque renderers to blend correctly with the colors underneath in the depth buffer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-renderer"><a class="header" href="#text-renderer">Text Renderer</a></h1>
<p>The text renderer is quite opinionated to enable some memory optimizations.
This lib uses <a href="https://github.com/mooman219/fontdue"><code>fontdue</code></a> to rasterize glyphs to a <code>Bitmap</code> that contains a 
coverage value that signifies how much the letter shape covers that location. This
is stored in an <code>Atlas</code> of glyph bitmaps and sampled from in a shader. Each time a <code>Text</code>
element updates its <code>String</code> value, the system checks for a differential in the letters
at each location and obtains the <code>TextureCoords</code> for where in the <code>Atlas</code> that shape exists.
The shader matches the texture coords to a bbox with dimensions determined by the letter 
shape and offset. Each letter needs to be stored just once per <code>Text</code> element and can be 
referenced multiple times without needing to store again. When changing text frequently
glyphs can be freed from the <code>Atlas</code> if not referenced any longer. This requires removing
part of the <code>wgpu::Texture</code> contents and when needing to insert a new glyph organization can 
be tricky if the size of the new glyph is not aligned. Padding is inserted to give each
glyph a consistent slot to inhabit. With mono-spaced fonts each character has the same
dimensions which allows this padding to be minimal as each shape size is known/consistent.
If one shape were bigger we could not know when the <code>Atlas</code> would need to put the bigger shape at a 
location and have to default to every slot being as big as the largest character. Memory
can be saved by only using mono-spaced fonts and by limiting the sizes of fonts
to a set number. 3 sizes of <code>Text</code> can be used which have been calibrated to be reasonable
on most devices. This fixed number creates consistent UI elements as well by not having
jitter using fractional sizing differences. This is a perfect symbiosis of performance and
aligning style to meet functionality. </p>
<h3 id="usage-3"><a class="header" href="#usage-3">Usage</a></h3>
<p>To spawn a <code>Text</code> element, use the <code>TextBundle</code> </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TextBundle {
    pub pos: Position&lt;InterfaceContext&gt;,
    pub area: Area&lt;InterfaceContext&gt;,
    pub layer: Layer,
    pub text: Text,
    pub scale_alignment: TextScaleAlignment,
    pub color: Color,
    pub wrap_style: TextWrapStyle,
    /* private fields */
}
<span class="boring">}</span></code></pre></pre>
<p>This will create the required components to hook this entity into the 
text pipeline. All elements employ <code>Cache</code> and <code>Extraction</code> to keep changes to 
the gpu minimal. Wrap this bundle in a <code>Request</code> to ensure it gets spawned at the 
right time.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>visualizer.add_entities(vec![Request::new(TextBundle::new(...))]);
<span class="boring">}</span></code></pre></pre>
<h3 id="alignments"><a class="header" href="#alignments">Alignments</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum TextScaleAlignment {
    Small,
    Medium,
    Large,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h3>
<p>When rendering on devices with a <code>ScaleFactor</code> not equal to <code>1</code>, the <code>Font</code> size is scaled before rasterization of <code>Glyph</code>s as stretching <code>Bitmap</code>s of the 
glyph afterward to account for scaling would cause undesirable visual artifacts. <code>TextLetterDimensions</code> holds <code>Area&lt;DeviceContext&gt;</code> to illustrate that
the letter sizes already have scaling accounted for.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="visibility"><a class="header" href="#visibility">Visibility</a></h1>
<p>The <code>Visibility</code> struct handles the notion of being on-screen and by what amount with <code>VisibleSection</code>.
To enable this in an entity add the <code>EnableVisibility</code> bundle which hooks it
into the <code>calc_visibility</code> system.
This is run twice every frame; once after initialization, and once after processing completes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bundle = (..., EnableVisibility::default());
// ...
if visibility.visible() {
    // ... do something because visible
}
<span class="boring">}</span></code></pre></pre>
<p>When an entity is partially off-screen it can be helpful to read from the <code>VisibleSection</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(section) = visible_section.section() {
    // ... react according to actual in-screen pos/area
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="focus"><a class="header" href="#focus">Focus</a></h1>
<p>This struct is for determining the <code>Focus</code> in the UI. A resource <code>FocusedEntity</code> exists
that is set when input is set to an entity. It is a simple implementation and put here 
for reference.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Focus {
    pub(crate) focused: bool,
}

impl Focus {
    pub fn new() -&gt; Self {
        Self { focused: false }
    }
    pub fn focus(&amp;mut self) {
        self.focused = true;
    }
    pub fn blur(&amp;mut self) {
        self.focused = false;
    }
    pub fn focused(&amp;self) -&gt; bool {
        self.focused
    }
}
<span class="boring">}</span></code></pre></pre>
<p>A <code>FocusInputListener</code> can be attached to an entity with <code>Focus</code> to signal the 
<code>VirtualKeyboard</code> to open when receiving focus.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>visualizer.add_entities(vec![(
    // ... other components
        Focus::new(),
        FocusInputListener {},
    )]);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="touch"><a class="header" href="#touch">Touch</a></h1>
<p>This module handles input from mouse clicks/touchscreen touches. Both of these events get
distilled to a <code>TouchEvent</code> to handle both input methods uniformly. The <code>Visualizer</code> registers
these events and sends them to the <code>Job</code> to be processed. Any <code>Touch</code> that is not grabbed by a
<code>TouchListener</code> resets <code>Focus</code> and clears the <code>FocusedEntity</code>. If the <code>Touch</code> is within the bounds
of the <code>Area</code> of an entity that opt in to have a <code>TouchListener</code>, it is grabbed and prevents any underlying
entities from receiving that <code>Touch</code>. </p>
<h3 id="touch-listeners"><a class="header" href="#touch-listeners">Touch Listeners</a></h3>
<p>Entities can listen to <code>OnPress</code> and <code>OnRelease</code> touch types that trigger when a <code>Touch</code> begins in the area,
or when both the beginning and end of the <code>Touch</code> are within the bounds. This is to prevent errant presses from
triggering action when not intended. 3 aspects can be read from this input for each entity.
<code>TouchedState</code> holds whether it is currently pressed. This lasts for one loop then is reset in <code>SyncPoint::Finish</code>.
<code>ToggleState</code> tracks toggling of the entity. One press enables and the consecutive press disables.
<code>TouchLocation</code> can be read to see where the press was received within the <code>Area</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Touchable::new(TouchListener::on_press())
// or
Touchable::new(TouchListener::on_release())
<span class="boring">}</span></code></pre></pre>
<h3 id="tracking"><a class="header" href="#tracking">Tracking</a></h3>
<p>On touchscreens multiple <code>Interactor</code>s can be active at the same time. This can be unintentional such as 
resting your hand on the phone screen when reaching for a button. This cannot happen on mouse devices as the
mouse is the only <code>Interactor</code>. To prevent glitch presses due to extra touch interaction, the first interactor
is set as the <code>Primary</code> interactor and all other presses are tracked but secondary and not considered for
triggering events. Once the <code>Primary</code> is released, other presses can be activated as the primary again.</p>
<h3 id="adapters"><a class="header" href="#adapters">Adapters</a></h3>
<p>Each source has an adapter which can be used to read the current state of presses. <code>TouchAdapter</code> and <code>MouseAdapter</code> fill
these roles. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="orientation"><a class="header" href="#orientation">Orientation</a></h1>
<p><code>Orientation</code> is set on window resizing to be read if needing to respond to changes in
orientation. Available options are </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Orientation {
    Portrait(f32),
    Landscape(f32),
}
<span class="boring">}</span></code></pre></pre>
<p>They hold the aspect ratio of each option for reference. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instance-tools"><a class="header" href="#instance-tools">Instance Tools</a></h1>
<p>This came to be when I saw a pattern arise from using instances to achieve performant
rendering. I found I could automate some of the structure needed to have a staging buffer 
to hold changes and only write changed regions. I also found a way to elide rewriting buffers
on removal of instances by employing a <code>NullBit</code>. This marks any data for that instance
as invalid and multiplies any attributes to 0 in a shader conditionally culling the 
shapes as gpu drivers discard any fragments with 0 area. Otherwise, we would have to 
remove the element from the drawing range by rewriting all other attributes after the hole.
Instead, I found it easier to just drop the one instance and mark it as a hole to be filled
by the next instance that is needed.</p>
<h3 id="instance-attribute-manager"><a class="header" href="#instance-attribute-manager">Instance Attribute Manager</a></h3>
<p>All data for an instance is broken into separate buffers to allow different rates of
writing to the buffer based on how often the data changes. Each has its own gpu resource to
let it update only the parts needing changes. One attribute could be the <code>Position</code> of an
element which might be changed frequently when moving, but the color would not change as it
moves. This architecture elides rewriting the colors as well when just the <code>Position</code> needs
rewriting. </p>
<p>Here is an excerpt from the <code>TextRenderer</code> which employs usage of <code>InstanceAttributeManager</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>glyph_positions: InstanceAttributeManager::new::&lt;AttributeType&gt;(&amp;gfx_surface, *max),
<span class="boring">}</span></code></pre></pre>
<p>It is passed the <code>GfxSurface</code> and the <code>max</code> elements to hold initially before growing.
The <code>InstanceAttributeManager</code> uses the <code>size_of&lt;T&gt;</code> * max to get the actual byte size.</p>
<p>You can queue writes to the buffer using</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>InstanceAttributeManage::queue_write(...);
<span class="boring">}</span></code></pre></pre>
<p>You can grow the buffer when needed using</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>InstanceAttributeManager::grow(...);
<span class="boring">}</span></code></pre></pre>
<p>Finally, you can push the writes to the gpu using</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>InstanceAttributeManager::write(...);
<span class="boring">}</span></code></pre></pre>
<h3 id="key"><a class="header" href="#key">Key</a></h3>
<p>Sometimes you will need to associate a <code>Key</code> with an instance to keep track of its lifetime.
This can be accomplished using a <code>KeyFactory</code> and <code>KeyFactory::generate()</code> which will
get the next free key unique to the factory.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let key = key_factory.generate();
<span class="boring">}</span></code></pre></pre>
<h3 id="index"><a class="header" href="#index">Index</a></h3>
<p>The attributes are stored by <code>Index</code> in a buffer. This is useful for finding the 
byte offset required by gpu writing commands and for referencing an <code>Instance</code>s data to 
nullify it or update it. This is stored in an <code>Indexer</code> which takes the <code>Key</code> type to 
associate with the <code>Index</code>. This is useful because the <code>Index</code> may change but the <code>Key</code>
reference will point to the right location.</p>
<h5 id="indexer-overview"><a class="header" href="#indexer-overview">Indexer Overview</a></h5>
<p>Indexer can be used as such. </p>
<ul>
<li><code>::has_instances()</code> to check if anything is present.</li>
<li><code>::max()</code> for the current max.</li>
<li><code>::count()</code> for the current number of instances.</li>
<li><code>::next(key)</code> to get the next index and tie it to the key given.</li>
<li><code>::remove(key)</code> to remove the index associated with the key.</li>
<li><code>::get_index(key)</code> to get the index from a key.</li>
<li><code>::should_grow()</code> to signal more instances than max have been requested. If this should
grow then the <code>::max()</code> will return the max needed to fit the requested amount.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time"><a class="header" href="#time">Time</a></h1>
<p>A <code>Timer</code> is present to mark things that should happen over time.
One can obtain a <code>TimeMarker</code> at a specific point in time.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn system(timer: Res&lt;Timer&gt;) {
    let now = timer.mark();
}
<span class="boring">}</span></code></pre></pre>
<p>The difference in <code>TimeMarker</code>s can be obtained by </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>timer.time_since(...);
<span class="boring">}</span></code></pre></pre>
<p>The frame time can be obtained by using</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let frame_time = timer.frame_diff();
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runner-1"><a class="header" href="#runner-1">Runner</a></h1>
<p>The <code>Visualizer</code> can be used without a <code>Runner</code> to have full control of the event_loop. One would have to 
call the triggers associated with <code>Visualizer</code> to correctly use the struct and for usability, a <code>Runner</code> is 
provided as a useful solution to invoke the visualizer's tools.</p>
<p>A <code>Runner</code> has little data so instantiation is simple</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let runner = Runner::new();
<span class="boring">}</span></code></pre></pre>
<p>Natively it temporarily holds <code>desktop_dimensions</code> and <code>AndroidApp</code> to forward to the event
loop.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Runner::new()
        .with_desktop_dimensions((400, 600))
        .native_run::&lt;Engen&gt;(visualizer);
<span class="boring">}</span></code></pre></pre>
<p>can be used to set fixed dimensions on desktop.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Runner::new()
        .with_android_app(android_app)
        .native_run::&lt;Engen&gt;(visualizer);
<span class="boring">}</span></code></pre></pre>
<p>for Android, the system needs to be passed an <code>AndroidApp</code> to interact with the 
Android OS and invoke commands.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Runner::new().web_run::&lt;Engen&gt;(visualizer, &quot;./worker.js&quot;.to_string());
<span class="boring">}</span></code></pre></pre>
<p>To accomplish a background thread in the browser, the <code>Runner</code> must be passed the 
path to a Web Worker. See <a href="pages/../introduction.html">introduction</a> for web setup.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
